module Main where

import qualified Data.ByteString.Lazy as B
import SHA1 (Digest (..), sha1)
import Test.Hspec (Spec, describe, hspec, it, shouldBe)

---- SHA-1 spec ----------------------------------------------------------------

sha1Spec :: Spec
sha1Spec = describe "SHA1" $ do
  it "Returns a 160 bit digest that matches the SHA-1 hash of testVector0" $
    sha1 testVector0 `shouldBe` testOutput0
  it "Returns a 160 bit digest that matches the SHA-1 hash of testVector1" $
    sha1 testVector1 `shouldBe` testOutput1
  it "Returns a 160 bit digest that matches the SHA-1 hash of testVector2" $
    sha1 testVector2 `shouldBe` testOutput2
  it "Returns a 160 bit digest that matches the SHA-1 hash of testVector3" $
    sha1 testVector3 `shouldBe` testOutput3

---- Hspec entry point ---------------------------------------------------------

main :: IO ()
main = hspec $ do
  describe "SHA1" $ do
    sha1Spec

---- SHA-1 testing constants ---------------------------------------------------

testVector0 :: B.ByteString
testVector0 = B.pack [0x61, 0x62, 0x63]

testVector1 :: B.ByteString
testVector1 =
  B.pack
    [ 0x61,
      0x62,
      0x63,
      0x64,
      0x62,
      0x63,
      0x64,
      0x65,
      0x63,
      0x64,
      0x65,
      0x66,
      0x64,
      0x65,
      0x66,
      0x67,
      0x65,
      0x66,
      0x67,
      0x68,
      0x66,
      0x67,
      0x68,
      0x69,
      0x67,
      0x68,
      0x69,
      0x6A,
      0x68,
      0x69,
      0x6A,
      0x6B,
      0x69,
      0x6A,
      0x6B,
      0x6C,
      0x6A,
      0x6B,
      0x6C,
      0x6D,
      0x6B,
      0x6C,
      0x6D,
      0x6E,
      0x6C,
      0x6D,
      0x6E,
      0x6F,
      0x6D,
      0x6E,
      0x6F,
      0x70,
      0x6E,
      0x6F,
      0x70,
      0x71
    ]

testVector2 :: B.ByteString
testVector2 =
  B.pack
    [ 0x61,
      0x62,
      0x63,
      0x64,
      0x65,
      0x66,
      0x67,
      0x68,
      0x62,
      0x63,
      0x64,
      0x65,
      0x66,
      0x67,
      0x68,
      0x69,
      0x63,
      0x64,
      0x65,
      0x66,
      0x67,
      0x68,
      0x69,
      0x6A,
      0x64,
      0x65,
      0x66,
      0x67,
      0x68,
      0x69,
      0x6A,
      0x6B,
      0x65,
      0x66,
      0x67,
      0x68,
      0x69,
      0x6A,
      0x6B,
      0x6C,
      0x66,
      0x67,
      0x68,
      0x69,
      0x6A,
      0x6B,
      0x6C,
      0x6D,
      0x67,
      0x68,
      0x69,
      0x6A,
      0x6B,
      0x6C,
      0x6D,
      0x6E,
      0x68,
      0x69,
      0x6A,
      0x6B,
      0x6C,
      0x6D,
      0x6E,
      0x6F,
      0x69,
      0x6A,
      0x6B,
      0x6C,
      0x6D,
      0x6E,
      0x6F,
      0x70,
      0x6A,
      0x6B,
      0x6C,
      0x6D,
      0x6E,
      0x6F,
      0x70,
      0x71,
      0x6B,
      0x6C,
      0x6D,
      0x6E,
      0x6F,
      0x70,
      0x71,
      0x72,
      0x6C,
      0x6D,
      0x6E,
      0x6F,
      0x70,
      0x71,
      0x72,
      0x73,
      0x6D,
      0x6E,
      0x6F,
      0x70,
      0x71,
      0x72,
      0x73,
      0x74,
      0x6E,
      0x6F,
      0x70,
      0x71,
      0x72,
      0x73,
      0x74,
      0x75
    ]

testVector3 :: B.ByteString
testVector3 = B.pack $ replicate 1000000 0x61

testOutput0 :: Digest
testOutput0 = Digest 0xa9993e36 0x4706816a 0xba3e2571 0x7850c26c 0x9cd0d89d

testOutput1 :: Digest
testOutput1 = Digest 0x84983e44 0x1c3bd26e 0xbaae4aa1 0xf95129e5 0xe54670f1

testOutput2 :: Digest
testOutput2 = Digest 0xa49b2446 0xa02c645b 0xf419f995 0xb6709125 0x3a04a259

testOutput3 :: Digest
testOutput3 = Digest 0x34aa973c 0xd4c4daa4 0xf61eeb2b 0xdbad2731 0x6534016f
